import pandas as pd
from sklearn.preprocessing import OneHotEncoder

from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score, roc_auc_score, roc_curve, f1_score
from keras.models import Sequential
from keras.layers import Dense
from keras import backend as K
from keras import optimizers
from sklearn.preprocessing import LabelEncoder

data = pd.read_csv('testing.csv', delimiter=',')
test = pd.read_csv('testing.csv', delimiter=',')
#print(data['train_label'].dtype)



'''label_map = {'t': 1, 'f': 0}
data['train_label'] = data['train_label'].map(label_map)
test['train_label'] = test['train_label'].map(label_map)'''
label_map = {True: 1, False: 0}
data['train_label'] = data['train_label'].map(label_map)
test['train_label'] = test['train_label'].map(label_map)


seed = 50 
#train_data, test_data, train_label, test_label = train_test_split(X,train_label,test_size=0.1, random_state = seed)
train_label = data.pop('train_label')
test_label = test.pop('train_label')

dropList = ['index','Unnamed: 0','Unnamed: 0.1','assign_date','cve_publish_date','cve_id','cwe_id','cvss2_basescore','cvss2_exploitabilityscore',\
            'cvss2_impactscore','cvss2_obtainallprivilege','cvss2_obtainotherprivilege','cvss2_obtainuserprivilege',\
            'cvss2_severity','cvss2_userinteractionrequired','cve_description','reference_tag','reference_source',\
            'cpe_products','cpe_vendors','dw_post_content','dw_market_item']
#train_data = data.drop('index',axis = 1)

train_data = data
test_data = test
for item in dropList:
    train_data = train_data.drop(item,axis = 1)
    test_data = test_data.drop(item,axis = 1)
#train_data = train_data.drop('cve_description',axis = 1)


features_to_encode = train_data.columns[train_data.dtypes==object].tolist()  

train_label = train_label.values
train_data = train_data.values
test_label = test_label.values
test_data = test_data.values

train_data = train_data.astype(str)
test_data = test_data.astype(str)
train_label = train_label.reshape((len(train_label), 1))
test_label = test_label.reshape((len(test_label), 1))
#*********************************************
#num of columns is different in test and train **REQ FIX
def prepare_inputs(X_train, X_test):
	ohe = OneHotEncoder(handle_unknown='ignore')
	ohe.fit(X_train)
    
	X_train_enc = ohe.transform(X_train)
	X_test_enc = ohe.transform(X_test)
	return X_train_enc, X_test_enc

def prepare_targets(y_train, y_test):
	le = LabelEncoder()
	le.fit(y_train)
	y_train_enc = le.transform(y_train)
	y_test_enc = le.transform(y_test)
	return y_train_enc, y_test_enc

# prepare input data
train_data_enc, test_data_enc = prepare_inputs(train_data, test_data)
# prepare output data
train_label_enc, test_label_enc = prepare_targets(train_label, test_label)

model = Sequential()
model.add(Dense(10, input_dim=train_data_enc.shape[1], activation='relu'))
model.add(Dense(train_data_enc.shape[1], activation='relu'))
model.add(Dense(1, activation='sigmoid'))

def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))

opt = optimizers.Adam(learning_rate=0.0001)
model.compile(loss='mse', optimizer=opt,  metrics=['accuracy',f1_m,precision_m, recall_m])

# fit the keras model on the dataset
model.fit(train_data_enc, train_label_enc, epochs=100, batch_size=100, verbose=2)

loss, accuracy, f1_score, precision, recall = model.evaluate(test_data_enc, test_label_enc, verbose=0)

print('Neural Network')
print('Accuracy: %.2f' % (accuracy))
print('loss: %.2f' % (loss))
print('f1_score: %.2f' % (f1_score))
print('precision: %.2f' % (precision))
print('recall: %.2f' % (recall))
